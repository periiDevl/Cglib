#pragma once
// Forward rendering - lighting computed directly
const char *forwardVertexShaderSource = "#version 330 core\n"
"layout(location=0) in vec3 aPos;\n"
"layout(location=1) in vec3 aNormal;\n"
"uniform mat4 model;\n"
"uniform mat4 view;\n"
"uniform mat4 projection;\n"
"out vec3 FragPos;\n"
"out vec3 Normal;\n"
"out vec3 ViewPos;\n"
"void main(){\n"
" vec4 viewPos = view * model * vec4(aPos, 1.0);\n"
" ViewPos = viewPos.xyz;\n"
" gl_Position = projection * viewPos;\n"
" FragPos = vec3(model * vec4(aPos, 1.0));\n"
" Normal = mat3(transpose(inverse(view * model))) * aNormal;\n"
"}\0";

const char *forwardFragmentShaderSource = "#version 330 core\n"
"out vec4 FragColor;\n"
"in vec3 FragPos;\n"
"in vec3 Normal;\n"
"in vec3 ViewPos;\n"
"uniform vec4 objectColor;\n"
"struct Light{\n"
" vec3 position;\n"
" vec3 color;\n"
" float ambient;\n"
" float diffuse;\n"
" float specular;\n"
"};\n"
"uniform Light lights[4];\n"
"uniform int numLights;\n"
"void main(){\n"
" vec3 norm = normalize(Normal);\n"
" vec3 viewDir = normalize(-ViewPos);\n"
" vec3 result = vec3(0.0);\n"
" for(int i=0; i<numLights; i++){\n"
" vec3 ambient = lights[i].ambient * lights[i].color;\n"
" vec3 lightDir = normalize(lights[i]. position - FragPos);\n"
" float diff = max(dot(norm, lightDir), 0.0);\n"
" vec3 diffuse = lights[i].diffuse * diff * lights[i].color;\n"
" vec3 halfwayDir = normalize(lightDir + viewDir);\n"
" float spec = pow(max(dot(norm, halfwayDir), 0.0), 32.0);\n"
" vec3 specular = lights[i].specular * spec * lights[i].color;\n"
" result += ambient + diffuse + specular;\n"
" }\n"
" FragColor = vec4(result * objectColor.rgb, 1.0);\n"
"}\0";

// Depth pass for SSAO - render positions/normals
const char *depthVertexShaderSource = "#version 330 core\n"
"layout(location=0) in vec3 aPos;\n"
"layout(location=1) in vec3 aNormal;\n"
"uniform mat4 model;\n"
"uniform mat4 view;\n"
"uniform mat4 projection;\n"
"out vec3 FragPos;\n"
"out vec3 Normal;\n"
"void main(){\n"
" vec4 viewPos = view * model * vec4(aPos, 1.0);\n"
" FragPos = viewPos.xyz;\n"
" gl_Position = projection * viewPos;\n"
" Normal = mat3(transpose(inverse(view * model))) * aNormal;\n"
"}\0";

const char *depthFragmentShaderSource = "#version 330 core\n"
"layout(location=0) out vec4 gPosition;\n"
"layout(location=1) out vec4 gNormal;\n"
"in vec3 FragPos;\n"
"in vec3 Normal;\n"
"void main(){\n"
" gPosition = vec4(FragPos, 1.0);\n"
" gNormal = vec4(normalize(Normal), 1.0);\n"
"}\0";

// SSAO shader - identical to before
const char *ssaoVertexShaderSource = "#version 330 core\n"
"layout(location=0) in vec2 aPos;\n"
"layout(location=1) in vec2 aTexCoords;\n"
"out vec2 TexCoords;\n"
"void main(){\n"
" TexCoords = aTexCoords;\n"
" gl_Position = vec4(aPos, 0.0, 1.0);\n"
"}\0";

const char *ssaoFragmentShaderSource = "#version 330 core\n"
"out vec4 FragColor;\n"
"in vec2 TexCoords;\n"
"uniform sampler2D gPosition;\n"
"uniform sampler2D gNormal;\n"
"uniform sampler2D texNoise;\n"
"uniform vec3 samples[64];\n"
"uniform mat4 projection;\n"
"uniform vec2 screenSize;\n"
"void main(){\n"
" vec3 fragPos = texture(gPosition, TexCoords).xyz;\n"
" vec3 normal = normalize(texture(gNormal, TexCoords).rgb);\n"
" if(length(normal) < 0.1){\n"
" FragColor = vec4(1.0);\n"
" return;\n"
" }\n"
" vec2 noiseScale = screenSize / 4.0;\n"
" vec3 randomVec = normalize(texture(texNoise, TexCoords * noiseScale).xyz);\n"
" vec3 tangent = normalize(randomVec - normal * dot(randomVec, normal));\n"
" vec3 bitangent = cross(normal, tangent);\n"
" mat3 TBN = mat3(tangent, bitangent, normal);\n"
" float occlusion = 0.0;\n"
" float radius = 0.5;\n"
" float bias = 0.025;\n"
" for(int i = 0; i < 64; ++i){\n"
" vec3 samplePos = TBN * samples[i];\n"
" samplePos = fragPos + samplePos * radius;\n"
" vec4 offset = vec4(samplePos, 1.0);\n"
" offset = projection * offset;\n"
" offset.xyz /= offset.w;\n"
" offset.xyz = offset.xyz * 0.5 + 0.5;\n"
" float sampleDepth = texture(gPosition, offset.xy).z;\n"
" float rangeCheck = smoothstep(0.0, 1.0, radius / abs(fragPos.z - sampleDepth));\n"
" occlusion += (sampleDepth >= samplePos.z + bias ?  1.0 : 0.0) * rangeCheck;\n"
" }\n"
" occlusion = 1.0 - (occlusion / 64.0);\n"
" FragColor = vec4(vec3(occlusion), 1.0);\n"
"}\0";

// Blur shader
const char *blurFragmentShaderSource = "#version 330 core\n"
"out vec4 FragColor;\n"
"in vec2 TexCoords;\n"
"uniform sampler2D ssaoInput;\n"
"void main(){\n"
" vec2 texelSize = 1.0 / vec2(textureSize(ssaoInput, 0));\n"
" float result = 0.0;\n"
" for (int x = -2; x < 2; ++x){\n"
" for (int y = -2; y < 2; ++y){\n"
" vec2 offset = vec2(float(x), float(y)) * texelSize;\n"
" result += texture(ssaoInput, TexCoords + offset).r;\n"
" }\n"
" }\n"
" FragColor = vec4(vec3(result / 16.0), 1.0);\n"
"}\0";

// Final composite shader
const char *compositeFragmentShaderSource = "#version 330 core\n"
"out vec4 FragColor;\n"
"in vec2 TexCoords;\n"
"uniform sampler2D sceneColor;\n"
"uniform sampler2D ssaoColor;\n"
"void main(){\n"
" vec3 color = texture(sceneColor, TexCoords).rgb;\n"
" float ao = texture(ssaoColor, TexCoords).r;\n"
" FragColor = vec4(color * ao, 1.0);\n"
"}\0";
