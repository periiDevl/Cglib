#pragma once
// Forward rendering - lighting computed directly
const char *forwardVertexShaderSource = "#version 330 core\n"
"layout(location=0) in vec3 aPos;\n"
"layout(location=1) in vec3 aNormal;\n"
"uniform mat4 model;\n"
"uniform mat4 view;\n"
"uniform mat4 projection;\n"
"out vec3 FragPos;\n"
"out vec3 Normal;\n"
"out vec3 ViewPos;\n"
"void main(){\n"
" vec4 viewPos = view * model * vec4(aPos, 1.0);\n"
" ViewPos = viewPos.xyz;\n"
" gl_Position = projection * viewPos;\n"
" FragPos = vec3(model * vec4(aPos, 1.0));\n"
" Normal = mat3(transpose(inverse(view * model))) * aNormal;\n"
"}\0";
const char *forwardFragmentShaderSource = "#version 330 core\n"
"out vec4 FragColor;\n"
"in vec3 FragPos;\n"
"in vec3 Normal;\n"
"in vec3 ViewPos;\n"
"uniform vec4 objectColor;\n"
"struct Light{\n"
" vec3 position;\n"
" vec3 color;\n"
" float ambient;\n"
" float diffuse;\n"
" float specular;\n"
"};\n"
"uniform Light lights[4];\n"
"uniform int numLights;\n"
"uniform samplerCube shadowMaps[4];\n"
"uniform float farPlane;\n"
"uniform int shadowMapCount;\n"
"vec3 sampleOffsetDirections[20] = vec3[](\n"
" vec3(1,1,1), vec3(1,-1,1), vec3(-1,-1,1), vec3(-1,1,1),\n"
" vec3(1,1,-1), vec3(1,-1,-1), vec3(-1,-1,-1), vec3(-1,1,-1),\n"
" vec3(1,1,0), vec3(1,-1,0), vec3(-1,-1,0), vec3(-1,1,0),\n"
" vec3(1,0,1), vec3(-1,0,1), vec3(1,0,-1), vec3(-1,0,-1),\n"
" vec3(0,1,1), vec3(0,-1,1), vec3(0,-1,-1), vec3(0,1,-1)\n"
");\n"
"float ShadowCalculation(vec3 fragPos, vec3 lightPos, samplerCube shadowMap, float lightIntensity){\n"
" vec3 fragToLight = fragPos - lightPos;\n"
" float currentDepth = length(fragToLight);\n"
" float shadow = 0.0;\n"
" float bias = 0.15;\n"
" int samples = 35;\n"
" float viewDistance = length(ViewPos);\n"
" float diskRadius = (1.0 + (viewDistance / farPlane)) / 25.0;\n"
" for(int i = 0; i < samples; ++i){\n"
"  float closestDepth = texture(shadowMap, fragToLight + sampleOffsetDirections[i] * diskRadius).r;\n"
"  closestDepth *= farPlane;\n"
"  if(currentDepth - bias > closestDepth)\n"
"   shadow += 1.0;\n"
" }\n"
" shadow /= float(samples);\n"
" shadow *= lightIntensity;\n"
" return shadow;\n"
"}\n"
"void main(){\n"
" vec3 norm = normalize(Normal);\n"
" vec3 viewDir = normalize(-ViewPos);\n"
" vec3 result = vec3(0.0);\n"
" for(int i = 0; i < numLights; i++){\n"
"  vec3 ambient = lights[i].ambient * lights[i].color;\n"
"  vec3 lightDir = normalize(lights[i].position - FragPos);\n"
"  float diff = max(dot(norm, lightDir), 0.0);\n"
"  vec3 diffuse = lights[i].diffuse * diff * lights[i].color;\n"
"  vec3 halfwayDir = normalize(lightDir + viewDir);\n"
"  float spec = pow(max(dot(norm, halfwayDir), 0.0), 32.0);\n"
"  vec3 specular = lights[i].specular * spec * lights[i].color;\n"
"  float shadow = 0.0;\n"
"  if(i < shadowMapCount){\n"
"   float lightIntensity = (lights[i].diffuse + lights[i].specular) * 0.5;\n"
"   if(i == 0) shadow = ShadowCalculation(FragPos, lights[i].position, shadowMaps[0], lightIntensity);\n"
"   else if(i == 1) shadow = ShadowCalculation(FragPos, lights[i].position, shadowMaps[1], lightIntensity);\n"
"   else if(i == 2) shadow = ShadowCalculation(FragPos, lights[i].position, shadowMaps[2], lightIntensity);\n"
"   else if(i == 3) shadow = ShadowCalculation(FragPos, lights[i].position, shadowMaps[3], lightIntensity);\n"
"  }\n"
"  result += ambient + (1.0 - shadow) * (diffuse + specular);\n"
" }\n"
" FragColor = vec4(result * objectColor.rgb, 1.0);\n"
"}\0";

// Depth pass for SSAO - render positions/normals
const char *depthVertexShaderSource = "#version 330 core\n"
"layout(location=0) in vec3 aPos;\n"
"layout(location=1) in vec3 aNormal;\n"
"uniform mat4 model;\n"
"uniform mat4 view;\n"
"uniform mat4 projection;\n"
"out vec3 FragPos;\n"
"out vec3 Normal;\n"
"void main(){\n"
" vec4 viewPos = view * model * vec4(aPos, 1.0);\n"
" FragPos = viewPos.xyz;\n"
" gl_Position = projection * viewPos;\n"
" Normal = mat3(transpose(inverse(view * model))) * aNormal;\n"
"}\0";

const char *depthFragmentShaderSource = "#version 330 core\n"
"layout(location=0) out vec4 gPosition;\n"
"layout(location=1) out vec4 gNormal;\n"
"in vec3 FragPos;\n"
"in vec3 Normal;\n"
"void main(){\n"
" gPosition = vec4(FragPos, 1.0);\n"
" gNormal = vec4(normalize(Normal), 1.0);\n"
"}\0";

// SSAO shader - identical to before
const char *ssaoVertexShaderSource = "#version 330 core\n"
"layout(location=0) in vec2 aPos;\n"
"layout(location=1) in vec2 aTexCoords;\n"
"out vec2 TexCoords;\n"
"void main(){\n"
" TexCoords = aTexCoords;\n"
" gl_Position = vec4(aPos, 0.0, 1.0);\n"
"}\0";

const char *ssaoFragmentShaderSource = "#version 330 core\n"
"out vec4 FragColor;\n"
"in vec2 TexCoords;\n"
"uniform sampler2D gPosition;\n"
"uniform sampler2D gNormal;\n"
"uniform sampler2D texNoise;\n"
"uniform vec3 samples[64];\n"
"uniform mat4 projection;\n"
"uniform vec2 screenSize;\n"
"void main(){\n"
" vec3 fragPos = texture(gPosition, TexCoords).xyz;\n"
" vec3 normal = normalize(texture(gNormal, TexCoords).rgb);\n"
" if(length(normal) < 0.1){\n"
" FragColor = vec4(1.0);\n"
" return;\n"
" }\n"
" vec2 noiseScale = screenSize / 4.0;\n"
" vec3 randomVec = normalize(texture(texNoise, TexCoords * noiseScale).xyz);\n"
" vec3 tangent = normalize(randomVec - normal * dot(randomVec, normal));\n"
" vec3 bitangent = cross(normal, tangent);\n"
" mat3 TBN = mat3(tangent, bitangent, normal);\n"
" float occlusion = 0.0;\n"
" float radius = 0.7;\n"
" float bias = 0.025;\n"
" for(int i = 0; i < 64; ++i){\n"
" vec3 samplePos = TBN * samples[i];\n"
" samplePos = fragPos + samplePos * radius;\n"
" vec4 offset = vec4(samplePos, 1.0);\n"
" offset = projection * offset;\n"
" offset.xyz /= offset.w;\n"
" offset.xyz = offset.xyz * 0.5 + 0.5;\n"
" float sampleDepth = texture(gPosition, offset.xy).z;\n"
" float rangeCheck = smoothstep(0.0, 1.0, radius / abs(fragPos.z - sampleDepth));\n"
" occlusion += (sampleDepth >= samplePos.z + bias ?  1.0 : 0.0) * rangeCheck;\n"
" }\n"
" occlusion = 1.0 - (occlusion / 64.0);\n"
" FragColor = vec4(vec3(occlusion), 1.0);\n"
"}\0";

// Blur shader
const char *blurFragmentShaderSource = "#version 330 core\n"
"out vec4 FragColor;\n"
"in vec2 TexCoords;\n"
"uniform sampler2D ssaoInput;\n"
"void main(){\n"
" vec2 texelSize = 1.0 / vec2(textureSize(ssaoInput, 0));\n"
" float result = 0.0;\n"
" for (int x = -2; x < 2; ++x){\n"
" for (int y = -2; y < 2; ++y){\n"
" vec2 offset = vec2(float(x), float(y)) * texelSize;\n"
" result += texture(ssaoInput, TexCoords + offset).r;\n"
" }\n"
" }\n"
" FragColor = vec4(vec3(result / 16.0), 1.0);\n"
"}\0";

// Final composite shader
const char *compositeFragmentShaderSource = "#version 330 core\n"
"out vec4 FragColor;\n"
"in vec2 TexCoords;\n"
"uniform sampler2D sceneColor;\n"
"uniform sampler2D ssaoColor;\n"
"void main(){\n"
" vec3 color = texture(sceneColor, TexCoords).rgb;\n"
" float ao = texture(ssaoColor, TexCoords).r;\n"
" FragColor = vec4(color * ao, 1.0);\n"
"}\0";
// Shadow map depth shader (renders to cubemap)
const char *shadowDepthVertexShaderSource = "#version 330 core\n"
"layout(location=0) in vec3 aPos;\n"
"uniform mat4 model;\n"
"void main(){\n"
" gl_Position = model * vec4(aPos, 1.0);\n"
"}\0";

const char *shadowDepthGeometryShaderSource = "#version 330 core\n"
"layout(triangles) in;\n"
"layout(triangle_strip, max_vertices=18) out;\n"
"uniform mat4 shadowMatrices[6];\n"
"out vec4 FragPos;\n"
"void main(){\n"
" for(int face = 0; face < 6; ++face){\n"
" gl_Layer = face;\n"
" for(int i = 0; i < 3; ++i){\n"
" FragPos = gl_in[i].gl_Position;\n"
" gl_Position = shadowMatrices[face] * FragPos;\n"
" EmitVertex();\n"
" }\n"
" EndPrimitive();\n"
" }\n"
"}\0";

const char *shadowDepthFragmentShaderSource = "#version 330 core\n"
"in vec4 FragPos;\n"
"uniform vec3 lightPos;\n"
"uniform float farPlane;\n"
"void main(){\n"
" float lightDistance = length(FragPos.xyz - lightPos);\n"
" lightDistance = lightDistance / farPlane;\n"
" gl_FragDepth = lightDistance;\n"
"}\0";

