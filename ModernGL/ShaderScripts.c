#include "ShaderScripts.h"
// Forward rendering - lighting computed directly
const char *forwardVertexShaderSource = "#version 330 core\n"
"layout(location=0) in vec3 aPos;\n"
"layout(location=1) in vec3 aNormal;\n"
"uniform mat4 model;\n"
"uniform mat4 view;\n"
"uniform mat4 projection;\n"
"out vec3 FragPos;\n"
"out vec3 Normal;\n"
"out vec3 ViewPos;\n"
"void main(){\n"
" vec4 viewPos = view * model * vec4(aPos, 1.0);\n"
" ViewPos = viewPos.xyz;\n"
" gl_Position = projection * viewPos;\n"
" FragPos = vec3(model * vec4(aPos, 1.0));\n"
" Normal = mat3(transpose(inverse(view * model))) * aNormal;\n"
"}\0";
const char *forwardFragmentShaderSource = "#version 330 core\n"
"out vec4 FragColor;\n"
"in vec3 FragPos;\n"
"in vec3 Normal;\n"
"in vec3 ViewPos;\n"
"uniform vec4 objectColor;\n"
"struct Light{\n"
" vec3 position;\n"
" vec3 color;\n"
" float ambient;\n"
" float diffuse;\n"
" float specular;\n"
"};\n"
"uniform Light lights[4];\n"
"uniform int numLights;\n"
"uniform samplerCube shadowMaps[4];\n"
"uniform float farPlane;\n"
"uniform int shadowMapCount;\n"
"uniform float shadowDarkness;\n" // can go >1.0 now
"struct Material {\n"
" float ambient;\n"
" float diffuse;\n"
" float specular;\n"
" float shininess;\n"
"};\n"
"uniform Material material;\n"
"vec3 sampleOffsetDirections[20] = vec3[](\n"
" vec3(1,1,1), vec3(1,-1,1), vec3(-1,-1,1), vec3(-1,1,1),\n"
" vec3(1,1,-1), vec3(1,-1,-1), vec3(-1,-1,-1), vec3(-1,1,-1),\n"
" vec3(1,1,0), vec3(1,-1,0), vec3(-1,-1,0), vec3(-1,1,0),\n"
" vec3(1,0,1), vec3(-1,0,1), vec3(1,0,-1), vec3(-1,0,-1),\n"
" vec3(0,1,1), vec3(0,-1,1), vec3(0,-1,-1), vec3(0,1,-1)\n"
");\n"
"float ShadowCalculation(vec3 fragPos, vec3 lightPos, samplerCube shadowMap, float lightIntensity){\n"
" vec3 fragToLight = fragPos - lightPos;\n"
" float currentDepth = length(fragToLight);\n"
" float shadow = 0.0;\n"
" float bias = 0.07;\n"
" int samples = 40;\n"
" float viewDistance = length(ViewPos);\n"
" float diskRadius = (1.0 + (viewDistance / farPlane)) / 50.0;\n"
" for(int i = 0; i < samples; ++i){\n"
"  float closestDepth = texture(shadowMap, fragToLight + sampleOffsetDirections[i] * diskRadius).r;\n"
"  closestDepth *= farPlane;\n"
"  if(currentDepth - bias > closestDepth)\n"
"   shadow += 1.0;\n"
" }\n"
" shadow /= float(samples);\n"
" shadow *= lightIntensity;\n"
" shadow *= shadowDarkness; // can now be >1.0 for darker shadows\n"
" return shadow;\n"
"}\n"
"void main(){\n"
" vec3 norm = normalize(Normal);\n"
" vec3 viewDir = normalize(-ViewPos);\n"
" vec3 result = vec3(0.0);\n"
" for(int i = 0; i < numLights; i++){\n"
"  vec3 ambient = material.ambient * lights[i].ambient * lights[i].color;\n"
"  vec3 lightDir = normalize(lights[i].position - FragPos);\n"
"  float diff = max(dot(norm, lightDir), 0.0);\n"
"  vec3 diffuse = material.diffuse * lights[i].diffuse * diff * lights[i].color;\n"
"  vec3 halfwayDir = normalize(lightDir + viewDir);\n"
"  float spec = pow(max(dot(norm, halfwayDir), 0.0), material.shininess);\n"
"  vec3 specular = material.specular * lights[i].specular * spec * lights[i].color;\n"
"  float shadow = 0.0;\n"
"  if(i < shadowMapCount){\n"
"   float lightIntensity = (lights[i].diffuse + lights[i].specular) * 0.5;\n"
"   if(i == 0) shadow = ShadowCalculation(FragPos, lights[i].position, shadowMaps[0], lightIntensity);\n"
"   else if(i == 1) shadow = ShadowCalculation(FragPos, lights[i].position, shadowMaps[1], lightIntensity);\n"
"   else if(i == 2) shadow = ShadowCalculation(FragPos, lights[i].position, shadowMaps[2], lightIntensity);\n"
"   else if(i == 3) shadow = ShadowCalculation(FragPos, lights[i].position, shadowMaps[3], lightIntensity);\n"
"  }\n"
"  // Apply shadow multiplier directly; clamp later to avoid breaking color\n"
"  vec3 lighting = ambient + max(0.0, 1.0 - shadow) * (diffuse + specular);\n"
"  result += lighting;\n"
" }\n"
" FragColor = vec4(clamp(result * objectColor.rgb, 0.0, 1.0), 1.0);\n"
"}\0";


// Depth pass for SSAO - render positions/normals
const char *depthVertexShaderSource = "#version 330 core\n"
"layout(location=0) in vec3 aPos;\n"
"layout(location=1) in vec3 aNormal;\n"
"uniform mat4 model;\n"
"uniform mat4 view;\n"
"uniform mat4 projection;\n"
"out vec3 FragPos;\n"
"out vec3 Normal;\n"
"void main(){\n"
" vec4 viewPos = view * model * vec4(aPos, 1.0);\n"
" FragPos = viewPos.xyz;\n"
" gl_Position = projection * viewPos;\n"
" Normal = mat3(transpose(inverse(view * model))) * aNormal;\n"
"}\0";

const char *depthFragmentShaderSource = "#version 330 core\n"
"layout(location=0) out vec4 gPosition;\n"
"layout(location=1) out vec4 gNormal;\n"
"in vec3 FragPos;\n"
"in vec3 Normal;\n"
"void main(){\n"
" gPosition = vec4(FragPos, 1.0);\n"
" gNormal = vec4(normalize(Normal), 1.0);\n"
"}\0";

// SSAO shader - identical to before
const char *ssaoVertexShaderSource = "#version 330 core\n"
"layout(location=0) in vec2 aPos;\n"
"layout(location=1) in vec2 aTexCoords;\n"
"out vec2 TexCoords;\n"
"void main(){\n"
" TexCoords = aTexCoords;\n"
" gl_Position = vec4(aPos, 0.0, 1.0);\n"
"}\0";

const char *ssaoFragmentShaderSource = "#version 330 core\n"
"out vec4 FragColor;\n"
"in vec2 TexCoords;\n"
"uniform sampler2D gPosition;\n"
"uniform sampler2D gNormal;\n"
"uniform sampler2D texNoise;\n"
"uniform vec3 samples[64];\n"
"uniform mat4 projection;\n"
"uniform vec2 screenSize;\n"
"void main(){\n"
" vec3 fragPos = texture(gPosition, TexCoords).xyz;\n"
" vec3 normal = normalize(texture(gNormal, TexCoords).rgb);\n"
" if(length(normal) < 0.1){\n"
"  FragColor = vec4(1.0);\n"
"  return;\n"
" }\n"
" vec2 noiseScale = screenSize / 4.0;\n"
" vec3 randomVec = normalize(texture(texNoise, TexCoords * noiseScale).xyz);\n"
" vec3 tangent = normalize(randomVec - normal * dot(randomVec, normal));\n"
" vec3 bitangent = cross(normal, tangent);\n"
" mat3 TBN = mat3(tangent, bitangent, normal);\n"
" float occlusion = 0.0;\n"
" float radius = 0.9;\n"
" float bias = 0.025;\n"
" for(int i = 0; i < 64; ++i){\n"
"  vec3 samplePos = TBN * samples[i];\n"
"  samplePos = fragPos + samplePos * radius;\n"
"  vec4 offset = vec4(samplePos, 1.0);\n"
"  offset = projection * offset;\n"
"  offset.xyz /= offset.w;\n"
"  offset.xyz = offset.xyz * 0.5 + 0.5;\n"
"  float sampleDepth = texture(gPosition, offset.xy).z;\n"
"  float rangeCheck = smoothstep(0.0, 1.0, radius / abs(fragPos.z - sampleDepth));\n"
"  occlusion += (sampleDepth >= samplePos.z + bias ?  1.0 : 0.0) * rangeCheck;\n"
" }\n"
" occlusion = 1.0 - (occlusion / 64.0);\n"
" // boost AO contrast and prevent full white (keeps effect in bright areas)\n"
" occlusion = clamp(0.1 + 0.8 * occlusion, 0.0, 1.0);\n"
" occlusion = pow(occlusion, 2.2); // optional gamma curve\n"
" FragColor = vec4(vec3(occlusion), 1.0);\n"
"}\0";

// Blur shader
const char *blurFragmentShaderSource = "#version 330 core\n"
"out vec4 FragColor;\n"
"in vec2 TexCoords;\n"
"uniform sampler2D ssaoInput;\n"
"void main(){\n"
" vec2 texelSize = 1.0 / vec2(textureSize(ssaoInput, 0));\n"
" float result = 0.0;\n"
" for (int x = -2; x < 2; ++x){\n"
" for (int y = -2; y < 2; ++y){\n"
" vec2 offset = vec2(float(x), float(y)) * texelSize;\n"
" result += texture(ssaoInput, TexCoords + offset).r;\n"
" }\n"
" }\n"
" FragColor = vec4(vec3(result / 16.0), 1.0);\n"
"}\0";

// Final composite shader
const char *compositeFragmentShaderSource = "#version 330 core\n"
"out vec4 FragColor;\n"
"in vec2 TexCoords;\n"
"uniform sampler2D sceneColor;\n"
"uniform sampler2D ssaoColor;\n"
"void main(){\n"
" vec3 color = texture(sceneColor, TexCoords).rgb;\n"
" float ao = texture(ssaoColor, TexCoords).r;\n"
" FragColor = vec4(color * ao, 1.0);\n"
"}\0";
// Shadow map depth shader (renders to cubemap)
const char *shadowDepthVertexShaderSource = "#version 330 core\n"
"layout(location=0) in vec3 aPos;\n"
"uniform mat4 model;\n"
"void main(){\n"
" gl_Position = model * vec4(aPos, 1.0);\n"
"}\0";

const char *shadowDepthGeometryShaderSource = "#version 330 core\n"
"layout(triangles) in;\n"
"layout(triangle_strip, max_vertices=18) out;\n"
"uniform mat4 shadowMatrices[6];\n"
"out vec4 FragPos;\n"
"void main(){\n"
" for(int face = 0; face < 6; ++face){\n"
" gl_Layer = face;\n"
" for(int i = 0; i < 3; ++i){\n"
" FragPos = gl_in[i].gl_Position;\n"
" gl_Position = shadowMatrices[face] * FragPos;\n"
" EmitVertex();\n"
" }\n"
" EndPrimitive();\n"
" }\n"
"}\0";

const char *shadowDepthFragmentShaderSource = "#version 330 core\n"
"in vec4 FragPos;\n"
"uniform vec3 lightPos;\n"
"uniform float farPlane;\n"
"void main(){\n"
" float lightDistance = length(FragPos.xyz - lightPos);\n"
" lightDistance = lightDistance / farPlane;\n"
" gl_FragDepth = lightDistance;\n"
"}\0";
// Add these to your ShaderScripts.h file

// Brightness extraction shader - extracts bright areas for bloom
const char *brightnessVertexShaderSource = "#version 330 core\n"
"layout(location=0) in vec2 aPos;\n"
"layout(location=1) in vec2 aTexCoords;\n"
"out vec2 TexCoords;\n"
"void main(){\n"
" TexCoords = aTexCoords;\n"
" gl_Position = vec4(aPos, 0.0, 1.0);\n"
"}\0";

const char *brightnessFragmentShaderSource = "#version 330 core\n"
"out vec4 FragColor;\n"
"in vec2 TexCoords;\n"
"uniform sampler2D hdrBuffer;\n"
"uniform float threshold;\n"
"void main(){\n"
" vec3 color = texture(hdrBuffer, TexCoords).rgb;\n"
" float brightness = dot(color, vec3(0.2126, 0.7152, 0.0722));\n"
" if(brightness > threshold)\n"
"  FragColor = vec4(color, 1.0);\n"
" else\n"
"  FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n"
"}\0";

// Gaussian blur shader for bloom
const char *gaussianBlurFragmentShaderSource = "#version 330 core\n"
"out vec4 FragColor;\n"
"in vec2 TexCoords;\n"
"uniform sampler2D image;\n"
"uniform bool horizontal;\n"
"uniform float weight[5] = float[](0.227027, 0.1945946, 0.1216216, 0.054054, 0.016216);\n"
"void main(){\n"
" vec2 tex_offset = 1.0 / textureSize(image, 0);\n"
" vec3 result = texture(image, TexCoords).rgb * weight[0];\n"
" if(horizontal){\n"
"  for(int i = 1; i < 5; ++i){\n"
"   result += texture(image, TexCoords + vec2(tex_offset.x * i, 0.0)).rgb * weight[i];\n"
"   result += texture(image, TexCoords - vec2(tex_offset.x * i, 0.0)).rgb * weight[i];\n"
"  }\n"
" } else {\n"
"  for(int i = 1; i < 5; ++i){\n"
"   result += texture(image, TexCoords + vec2(0.0, tex_offset.y * i)).rgb * weight[i];\n"
"   result += texture(image, TexCoords - vec2(0.0, tex_offset.y * i)).rgb * weight[i];\n"
"  }\n"
" }\n"
" FragColor = vec4(result, 1.0);\n"
"}\0";
// Final post-processing shader - HDR tone mapping with bloom and SSAO
const char *postProcFragmentShaderSource = "#version 330 core\n"
"out vec4 FragColor;\n"
"in vec2 TexCoords;\n"
"\n"
"uniform sampler2D hdrBuffer;\n"
"uniform sampler2D bloomBlur;\n"
"uniform sampler2D ssaoColor;\n"
"\n"
"uniform float exposure;\n"
"uniform float gamma;\n"
"uniform float bloomStrength;\n"
"uniform bool useBloom;\n"
"uniform bool useSSAO;\n"
"uniform int toneMapMode; // 0 = Reinhard, 1 = ACES\n"
"\n"
"vec3 toneMapReinhard(vec3 x)\n"
"{\n"
"    return x / (x + vec3(1.0));\n"
"}\n"
"\n"
"vec3 toneMapACES(vec3 x)\n"
"{\n"
"    const float a = 2.51;\n"
"    const float b = 0.03;\n"
"    const float c = 2.43;\n"
"    const float d = 0.59;\n"
"    const float e = 0.14;\n"
"    return clamp((x * (a * x + b)) / (x * (c * x + d) + e), 0.0, 1.0);\n"
"}\n"
"\n"
"void main()\n"
"{\n"
"    vec3 hdrColor = texture(hdrBuffer, TexCoords).rgb;\n"
"    vec3 bloomColor = texture(bloomBlur, TexCoords).rgb;\n"
"\n"
"    float ao = 1.0;\n"
"    if(useSSAO)\n"
"        ao = texture(ssaoColor, TexCoords).r;\n"
"\n"
"    if(useBloom)\n"
"        hdrColor += bloomColor * bloomStrength;\n"
"\n"
"    hdrColor *= ao;\n"
"\n"
"    // Apply exposure\n"
"    vec3 color = hdrColor * exposure;\n"
"\n"
"    // Tone mapping\n"
"    if(toneMapMode == 0)\n"
"        color = toneMapReinhard(color);\n"
"    else\n"
"        color = toneMapACES(color);\n"
"\n"
"    // Gamma correction\n"
"    color = pow(color, vec3(1.0 / gamma));\n"
"\n"
"    FragColor = vec4(color, 1.0);\n"
"}\0";
